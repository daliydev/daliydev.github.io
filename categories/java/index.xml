<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>java on Daily</title>
    <link>http://daliydev.github.io/categories/java/</link>
    <description>Recent content in java on Daily</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language><atom:link href="http://daliydev.github.io/categories/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[java] Adapter 패턴</title>
      <link>http://daliydev.github.io/post/java/adapter/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://daliydev.github.io/post/java/adapter/</guid>
      <description>어댑터 패턴은 서로 다른 인터페이스가 호환이 되지 않을 때 사용한다. 인터페이스에 영향받는 부분들을 수정하다가 시스템 장애가 발생하는 일이 발생할 수 있기 때문에,</description>
    </item>
    
    <item>
      <title>[java] Bridge 패턴</title>
      <link>http://daliydev.github.io/post/java/bridge/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://daliydev.github.io/post/java/bridge/</guid>
      <description>브릿지 패턴은 기능과 구현에 대해 클래스를 분리하여 독립적으로 변경이 가능하고 확장이 가능하도록 합니다. 즉, 양쪽 클래스의 결합도가 낮아져서 독립적으로 변경과</description>
    </item>
    
    <item>
      <title>[java] Builder 패턴</title>
      <link>http://daliydev.github.io/post/java/builder/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://daliydev.github.io/post/java/builder/</guid>
      <description>빌더 패턴은 필요한 데이터만 설정하여 불필요한 코드의 양을 줄이고, 가독성을 높일 수 있다. setter 메서드가 없으므로 변경 불가능한 객체를 만들 수 있고, 내부에 여러 생성</description>
    </item>
    
    <item>
      <title>[java] Command 패턴</title>
      <link>http://daliydev.github.io/post/java/command/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://daliydev.github.io/post/java/command/</guid>
      <description>커맨드 패턴은 요청을 객체로 캡슐화하여 처리하는 방식이다. 기능을 캡슐화함으로써 재사용성이 높은 클래스로 설계하는 패턴이다. 일반적으로 기능을 메서드로 정의</description>
    </item>
    
    <item>
      <title>[java] Composite 패턴</title>
      <link>http://daliydev.github.io/post/java/composite/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://daliydev.github.io/post/java/composite/</guid>
      <description>컴포지트 패턴은 클라이언트가 복합 객체나 단일 객체를 동일하게 취급하는 것을 목적으로 한다. 전체 구조를 나타내기 위해 객체를 트리 구조로 구성합니다. 예제) 이동</description>
    </item>
    
    <item>
      <title>[java] Decorator 패턴</title>
      <link>http://daliydev.github.io/post/java/decorator/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://daliydev.github.io/post/java/decorator/</guid>
      <description>데코레이터 패턴은 어떤 객체에 책임을 동적으로 추가하는 패턴입니다. 즉, 객체에 새로운 기능을 추가하거나 변화시켜서 기능을 유연하게 확장할 수 있게 해줍니다. 단</description>
    </item>
    
    <item>
      <title>[java] Facade 패턴</title>
      <link>http://daliydev.github.io/post/java/facade/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://daliydev.github.io/post/java/facade/</guid>
      <description>퍼사드 패턴은 구조 패턴의 한 종류이다. 설계의 목표는 서브시스템 간 종속성을 최소화하는 것. 서브시스템에 대한 의존성을 한곳으로 모을 수 있는 장점이 있지만, 클라</description>
    </item>
    
    <item>
      <title>[java] Factory 패턴</title>
      <link>http://daliydev.github.io/post/java/factory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://daliydev.github.io/post/java/factory/</guid>
      <description>팩토리 패턴은 객체 생성 로직을 분리하여 클라이언트와 결합도를 낮추어, 코드 변경 없이 기능을 확장하거나 변경할 수 있다 (OCP) 종류는 팩토리 메서드 패턴, 추상 팩토리 패</description>
    </item>
    
    <item>
      <title>[java] Flyweight 패턴</title>
      <link>http://daliydev.github.io/post/java/flyweight/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://daliydev.github.io/post/java/flyweight/</guid>
      <description>플라이웨이트 패턴은 객체 생성 횟수를 줄이고, 메모리 사용량을 줄이고 성능을 개선하기 위해 사용합니다. (객체를 공유하는 방식으로 메모리 사용량을 줄임) 예시)</description>
    </item>
    
    <item>
      <title>[java] image resize (javax.imageio.ImageIO)</title>
      <link>http://daliydev.github.io/post/java/resize/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://daliydev.github.io/post/java/resize/</guid>
      <description>Java에서 제공하는 패키지로 이미지 크기 변경하기. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import java.awt.Graphics; import java.awt.Image; import java.awt.image.BufferedImage; import java.io.File; import java.io.IOException; import javax.imageio.ImageIO; public class Resize { public static void main(String[] args)</description>
    </item>
    
    <item>
      <title>[java] Interpreter 패턴</title>
      <link>http://daliydev.github.io/post/java/interpreter/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://daliydev.github.io/post/java/interpreter/</guid>
      <description>인터프리터 패턴은 행위 패턴 중 하나이고, 일련의 규칙으로 정의된 언어를 해석하는 패턴이다. 예시로 자바 컴파일러나 정규 표현식, 번역기 등이 있다. 구조 Context 모든 expression</description>
    </item>
    
    <item>
      <title>[java] Iterator 패턴</title>
      <link>http://daliydev.github.io/post/java/iterator/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://daliydev.github.io/post/java/iterator/</guid>
      <description>이터레이터 패턴은 객체를 저장하는 방식은 보여주지 않으면서, 모든 항목에 접근할 수 있게 해준다. 반복 작업을 Iterator 인터페이스를 이용하여 캡슐화한다. 구조 Iterator 순서대</description>
    </item>
    
    <item>
      <title>[java] jpg 확장자가 gif처럼 동작하는 경우 (Convert File to Hex)</title>
      <link>http://daliydev.github.io/post/file-to-hex/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://daliydev.github.io/post/file-to-hex/</guid>
      <description>파일 객체를 hex로 변환해서 gif 인지 확인한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49</description>
    </item>
    
    <item>
      <title>[java] Mediator 패턴</title>
      <link>http://daliydev.github.io/post/java/mediator/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://daliydev.github.io/post/java/mediator/</guid>
      <description>중재자 패턴은 클래스 간의 복잡한 관계를 캡슐화하여 하나의 클래스에서 처리하는 패턴입니다. M:N 관계를 해당 패턴을 이용하면 M:1 관계로 만들어 객체들 사이의 결합도를</description>
    </item>
    
    <item>
      <title>[java] Memento 패턴</title>
      <link>http://daliydev.github.io/post/java/memento/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://daliydev.github.io/post/java/memento/</guid>
      <description>메멘토 패턴은 캡슐화를 유지하면서 상태를 저장/복원할 수 있는 패턴이다. 즉, 원하는 시점의 상태 복원이 가능해진다. 구조 Originator : 현재 상태를 저장하고 Memento 객체의 정보</description>
    </item>
    
    <item>
      <title>[java] Observer 패턴</title>
      <link>http://daliydev.github.io/post/java/observer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://daliydev.github.io/post/java/observer/</guid>
      <description>옵저버 패턴은 한 객체의 변경사항이 다른 객체들에 알려야 할 경우 사용한다.(one-to-many) 즉, 동적으로 변경이 필요한 경우 예제 1) 회사에서 임직원에</description>
    </item>
    
    <item>
      <title>[java] opencsv</title>
      <link>http://daliydev.github.io/post/java/csv/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://daliydev.github.io/post/java/csv/</guid>
      <description>csv는 표 형태의 데이터를 저장하는 파일 형식. 텍스트 기반 형식에 비해 간결해서 차지하는 용량이 작다. 하지만 각 필드에 대한 의미를 알 수 없다. 예제) java에</description>
    </item>
    
    <item>
      <title>[java] PDF to JPG (pdfbox)</title>
      <link>http://daliydev.github.io/post/java/pdf-to-jpg/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://daliydev.github.io/post/java/pdf-to-jpg/</guid>
      <description>PDF를 이미지로 변환하기 위해 Apache pdfbox 라이브러리를 사용한다. gradle 1 implementation group: &amp;#39;org.apache.pdfbox&amp;#39;, name: &amp;#39;pdfbox&amp;#39;, version: &amp;#39;2.0.26&amp;#39; maven 1 2 3 4 5 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.pdfbox&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;pdfbox&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.0.26&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 예제 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21</description>
    </item>
    
    <item>
      <title>[java] Prototype 패턴</title>
      <link>http://daliydev.github.io/post/java/prototype/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://daliydev.github.io/post/java/prototype/</guid>
      <description>프로토타입은 생성 패턴 중 하나이다. 객체 생성하는 데 시간과 비용이 많이 들고, 이미 유사한 객체가 존재하는 경우에 사용합니다. new를 이용해서 객체를 생성하지</description>
    </item>
    
    <item>
      <title>[java] Proxy 패턴</title>
      <link>http://daliydev.github.io/post/java/proxy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://daliydev.github.io/post/java/proxy/</guid>
      <description>프록시 패턴은 사용할 객체를 직접적으로 참조하는 것이 아닌 중간 객체를 통해 대상에 접근하는 방법이다. 단순히 보안상의 이유만으로 사용하는 것이 아닌, 캐싱 처리함</description>
    </item>
    
    <item>
      <title>[java] Singleton 패턴</title>
      <link>http://daliydev.github.io/post/java/singleton/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://daliydev.github.io/post/java/singleton/</guid>
      <description>싱글톤은 오직 한 개의 인스턴스만 생성하여, 불필요한 객체 생성을 피한다. Eager Initialization 사용하지 않더라도 인스턴스가 항상 생성된다는 단점. static은 Class가</description>
    </item>
    
    <item>
      <title>[java] State 패턴</title>
      <link>http://daliydev.github.io/post/java/state/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://daliydev.github.io/post/java/state/</guid>
      <description>상태 패턴은 상태에 따라 객체의 기능이 달라져야 할 때 사용한다. 상태를 관리하는 로직을 클래스 객체에서 분리해 관리하고, 기존 상태 클래스와 Context 객체의 수정 없이 새로</description>
    </item>
    
    <item>
      <title>[java] Strategy 패턴</title>
      <link>http://daliydev.github.io/post/java/strategy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://daliydev.github.io/post/java/strategy/</guid>
      <description>전략 패턴은 교체 가능한 알고리즘을 만드는데 사용되는 패턴이다. 동일 계열의 알고리즘을 정의하고, 각 알고리즘을 캡슐화하여 상호교환이 가능하도록 만든다. 단일</description>
    </item>
    
    <item>
      <title>[java] String 객체 메모리 취약점</title>
      <link>http://daliydev.github.io/post/java-memory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://daliydev.github.io/post/java-memory/</guid>
      <description>중요 문자열을 String 멤버 변수에 담는다면 메모리에 노출되기 때문에, Overwrite가 가능한 char[]를 이용한다. String 객체는 null을 대입해도, JVM</description>
    </item>
    
    <item>
      <title>[java] Template 패턴</title>
      <link>http://daliydev.github.io/post/java/template/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://daliydev.github.io/post/java/template/</guid>
      <description>템플릿 메서드 패턴은 공통으로 사용하는 메서드는 상위 클래스에서 정의하고, 다르게 구현할 메서드는 추상화하여 하위 클래스에서 구현하도록 하는 패턴이다. 코드 중</description>
    </item>
    
    <item>
      <title>[java] Visitor 패턴</title>
      <link>http://daliydev.github.io/post/java/visitor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://daliydev.github.io/post/java/visitor/</guid>
      <description>방문자 패턴은 객체 구조에서 분리시키는 패턴. 객체와 알고리즘을 분리하면 작업이 수행되는 객체의 클래스를 변경하지 않고도 새로운 알고리즘을 정의할 수 있다. 방문</description>
    </item>
    
    <item>
      <title>[java] 정렬 알고리즘</title>
      <link>http://daliydev.github.io/post/java/algorithm/sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://daliydev.github.io/post/java/algorithm/sort/</guid>
      <description>정렬 알고리즘 - 버블, 선택, 삽입, 퀵, 셸, 힙, 병합 1. 버블 정렬(bubble sort) 버블 정렬은 인접한 두 원소를 검사하여 정렬하는 알고리즘 1 2 3 4 5 6 7 8 9</description>
    </item>
    
    <item>
      <title>[java] 책임 연쇄(Chain of Responsibility) 패턴</title>
      <link>http://daliydev.github.io/post/java/chain-of-responsibility/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://daliydev.github.io/post/java/chain-of-responsibility/</guid>
      <description>책임 연쇄 패턴은 클라이언트로부터 받은 요청을 여러 객체들이 연쇄적으로 처리 기회를 가지는 패턴이다. 요청의 발신자와 수신자를 분리하고, 처리하는 객체는 여러개</description>
    </item>
    
    <item>
      <title>git 기본 명령어</title>
      <link>http://daliydev.github.io/post/etc/git-command/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://daliydev.github.io/post/etc/git-command/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70</description>
    </item>
    
  </channel>
</rss>
